# PatternDesign
C++设计模式

### 简单工厂模式 (Simple Factory Pattern)
**简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。**

该模式中主要的角色：

**工厂类**（Factory）：简单工厂模式的核心，用来创建所有的实例。

**抽象产品类**（Abstract Product）：从具体产品中抽象出来的类，就是所有对象的父类。

**具体产品类**（Concrete Product）:继承自抽象产品类，所有创建的对象都是某个具体产品类的实例。

**优点**

    工厂类是整个模式的关键.包含了必要的逻辑判断,根据外界给定的信息,决定究竟应该创建哪个具体类的对象.通过使用工厂类,外界可以从直接创建具体产品对象的尴尬局面摆脱出来,仅仅需要负责“消费”对象就可以了。而不必管这些对象究竟如何创建及如何组织的．明确了各自的职责和权利，有利于整个软件体系结构的优化。

**缺点**

    由于工厂类集中了所有实例的创建逻辑，违反了高内聚责任分配原则，将全部创建逻辑集中到了一个工厂类中；它所能创建的类只能是事先考虑到的，如果需要添加新的类，则就需要改变工厂类了。
    当系统中的具体产品类不断增多时候，可能会出现要求工厂类根据不同条件创建不同实例的需求．这种对条件的判断和对具体产品类型的判断交错在一起，很难避免模块功能的蔓延，对系统的维护和扩展非常不利；
    这些缺点在工厂方法模式中得到了一定的克服。


### 单例模式 (Singleton Pattern)
**保障一个类中只能有一个实例**

方法：使这个类自己保存一个实例

注意：多线程操作时需要加锁


### 代理模式 (Proxy Pattern)
**为其他对象提供一种代理来控制对这个对象的访问**

**Subject类**：定义了RealSubject和Proxy的共用接口，这样就在任何使用RealSubject的地方可以使用Proxy

**RealSubject类**：定义Proxy所代表的真实实体

**Proxy类**：保存一个引用使得代理可以访问实体，并提供一个与Subject的接口相同的接口，这样代理就可以用来替代实体

**应用**：

**远程代理**。也就是为一个对象在不同的地址空间提供局部代表。这样可以隐藏一个对象存在于不同地址空间的事实。

**虚拟代理**。是根据需要创建开销很大的对象，通过他来存放实例化需要很长时间的真是对象。

**安全代理**。用来控制真实对象访问时的权限。

**智能指引**。是指当调用真实的对象时，代理处理另外一些事。

### 策略模式(Strategy Pattern)
**定义了算法家族，分别封装起来，他们之间可以互相替换，让算法的变化不会影响到使用算法的用户**

### 模板模式(Template Pattern)
**在模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。这种类型的设计模式属于行为型模式。**